<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASA Treemap with Videos</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body { font: 12px Arial; }
        .node { border: solid 1px white; font: 10px sans-serif; line-height: 12px; overflow: hidden; position: absolute; text-indent: 2px; }
    </style>
</head>
<body>
    <div id="controls">
        <select id="treemap-tile">
            <option value="treemapBinary">Binary</option>
            <option value="treemapDice">Dice</option>
            <option value="treemapSlice">Slice</option>
            <option value="treemapSliceDice">SliceDice</option>
            <option value="treemapSquarify">Squarify</option>
        </select>
        <input type="radio" name="nesting-order" value="1" checked> Source > Category > Keyword
        <input type="radio" name="nesting-order" value="2"> Category > Source > Keyword
    </div>
    <div id="svg"></div>
    <div id="legend"></div>

    <script>
        var create_treemap = (data, tile) => {
            let color = d3.scaleOrdinal(d3.schemePaired);
            let format = d3.format(",d");
            let height = window.innerHeight;
            let width = window.innerWidth;
            let legendKeys = [];
            let margin = { top: 0, right: 0, bottom: 5, left: 0 };

            let tiles = {
                treemapBinary: d3.treemapBinary,
                treemapDice: d3.treemapDice,
                treemapSlice: d3.treemapSlice,
                treemapSliceDice: d3.treemapSliceDice,
                treemapSquarify: d3.treemapSquarify
            };

            let treemap = data => d3.treemap()
                .tile(tiles[tile])
                .size([width, height])
                .padding(1.5)
                .round(true)
                (d3.hierarchy(data)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value));

            let chart = () => {
                const root = treemap(data);

                const svg = d3.select("#svg").append("svg")
                    .attr("viewBox", [0, 0, width + margin.left + margin.right, height + margin.top + margin.bottom])
                    .style("font", "0.6em sans-serif");

                const leaf = svg.selectAll("g")
                    .data(root.leaves())
                    .join("g")
                    .attr("transform", d => `translate(${d.x0 + margin.left}, ${d.y0 + margin.top})`);

                leaf.append("title")
                    .text(d => {
                        let arr = d.ancestors().reverse().map(d => d.data.name);
                        let outStr;
                        if (hasNestingOrderChanged) {
                            outStr = `Keyword: ${d.data.name}\nUpload Source: ${arr[2]}\nCategory: ${arr[1]}\n\nCount: ${format(d.value)}`;
                        } else {
                            outStr = `Keyword: ${d.data.name}\nUpload Source: ${arr[1]}\nCategory: ${arr[2]}\n\nCount: ${format(d.value)}`;
                        }
                        return outStr;
                    });

                leaf.append("a")
                    .attr("xlink:href", d => {
                        let arr = d.ancestors().reverse().map(d => d.data.name);
                        return `https://data.nasa.gov/browse?q=${d.data.name}+${arr[1]}+${arr[2]}&sortBy=relevance`;
                    })
                    .append("rect")
                    .attr("id", d => (d.leafUid = ID("leaf")).id)
                    .attr("fill", d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })
                    .attr("fill-opacity", 0.6)
                    .attr("width", d => d.x1 - d.x0)
                    .attr("height", d => d.y1 - d.y0);

                leaf.append("clipPath")
                    .attr("id", d => (d.clipUid = ID("clip")).id)
                    .append("use")
                    .attr("xlink:href", d => `#${d.leafUid.id}`);

                leaf.append("text")
                    .attr("clip-path", d => `url(#${d.clipUid.id})`)
                    .selectAll("tspan")
                    .data(d => {
                        if (Number(d.value) > 0) {
                            let src = d.parent.parent.data.name;
                            if (legendKeys.indexOf(src) === -1) {
                                legendKeys.push(src);
                            }
                        }
                        return d.data.name.split(/(?=[A-Z][a-z])|\s+/g).concat(format(d.value));
                    })
                    .join("tspan")
                    .attr("class", "node-text")
                    .attr("x", 3)
                    .attr("y", (d, i, nodes) => `${(i === nodes.length - 1) * 0.3 + 1.1 + i * 0.9}em`)
                    .attr("fill-opacity", (d, i, nodes) => i === nodes.length - 1 ? 0.7 : null)
                    .text(d => { return d; });

                leaf.append("foreignObject")
                    .attr("width", d => d.x1 - d.x0)
                    .attr("height", d => d.y1 - d.y0)
                    .append("xhtml:body")
                    .style("margin", "0")
                    .style("padding", "0")
                    .style("background", "none")
                    .html((d, i) => `<video width="${d.x1 - d.x0}" height="${d.y1 - d.y0}" controls>
                                        <source src="${videos[i]}" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>`);

                var svg2 = d3.select("#legend")
                    .append("svg")
                    .attr("width", 500)
                    .attr("height", 25 * legendKeys.length);

                var legend = svg2.append("g")
                    .attr("class", "legend")
                    .attr('transform', 'translate(-20, 13)');

                legend.append('g')
                    .selectAll('.legend-group')
                    .data(legendKeys)
                    .join('g')
                    .attr('class', 'legend')
                    .attr('transform', (d, i) => `translate(20, ${i * 23})`)
                    .append('rect')
                    .attr('fill', (d) => color(d))
                    .attr('opacity', 0.7)
                    .attr('width', 15)
                    .attr('height', 15)
                    .attr('rx', 3);

                legend.selectAll('.legend')
                    .append('text')
                    .attr('font-size', "1em")
                    .attr('transform', (d, i) => `translate(19, 12)`)
                    .attr("class", "legend-text")
                    .text((d) => { return d; })
                    .on("click", (d) => {
                        document.location.href = `https://data.nasa.gov/browse?q=${d}&sortBy=relevance`;
                    });
            };
            chart();
        };

        var ID = (type) => {
            let out = {};
            let id_num = Math.random().toString(36).substr(2, 9);
            out["id"] = `O-${type}-${id_num}`;
            out["href"] = `${window.location.href}#${out["id"]}`;
            return out;
        };

        var swap_acronyms = (str) => {
            if (str in acronyms) {
                return toTitleCase(acronyms[str]["name"]);
            } else {
                return toTitleCase(str);
            }
        };

        var clean_data_treemap = (data) => {
            for (let i = 0; i < data["children"].length; i++) {
                data["children"][i]["name"] = swap_acronyms(data["children"][i]["name"]);
                for (let j = 0; j < data["children"][i]["children"].length; j++) {
                    data["children"][i]["children"][j]["name"] = swap_acronyms(data["children"][i]["children"][j]["name"]);
                    if (data["children"][i]["children"][j]["children"].length === 0) {
                        data["children"][i]["children"].splice(j, 1);
                        j--;
                    }
                }
                if (data["children"][i]["children"].length === 0) {
                    data.children.splice(i, 1);
                    i--;
                }
            }
            return data;
        };

        var changeNesting = (data) => {
            var out = { "name": "datasets", "children": [] };
            var obj = {};
            var temp_obj;
            var temp_obj2;
            var temp_obj3;

            for (let i = 0; i < data["children"].length; i++) {
                for (let j = 0; j < data["children"][i]["children"].length; j++) {
                    if (data["children"][i]["children"][j]["children"].length !== 0) {
                        if (!obj.hasOwnProperty(data["children"][i]["children"][j]["name"])) {
                            obj[data["children"][i]["children"][j]["name"]] = {};
                        }
                        obj[data["children"][i]["children"][j]["name"]][data["children"][i]["name"]] = {};
                        for (let x = 0; x < data["children"][i]["children"][j]["children"].length; x++) {
                            obj[data["children"][i]["children"][j]["name"]][data["children"][i]["name"]][data["children"][i]["children"][j]["children"][x]["name"]] = data["children"][i]["children"][j]["children"][x]["value"];
                        }
                    }
                }
            }

            for (let [category, cat_children] of Object.entries(obj)) {
                temp_obj = {};
                temp_obj["name"] = category;
                temp_obj["children"] = [];

                for (let [source, src_children] of Object.entries(cat_children)) {
                    temp_obj2 = {};
                    temp_obj2["name"] = source;
                    temp_obj2["children"] = [];

                    for (let [kw, count] of Object.entries(src_children)) {
                        temp_obj3 = {};
                        temp_obj3["name"] = kw;
                        temp_obj3["value"] = count;
                        temp_obj2["children"].push(temp_obj3);
                    }
                    temp_obj["children"].push(temp_obj2);
                }
                out["children"].push(temp_obj);
            }
            return out;
        };

        var toTitleCase = (str) => {
            return str.replace(/\w\S*/g, function(txt) {
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        };

        var data = {}; // Your data here
        var reversed_data = changeNesting(data);
        var hasNestingOrderChanged = false;

        document.addEventListener("DOMContentLoaded", () => {
            create_treemap(data, "treemapSquarify");

            $("div").on("change", "#treemap-tile", () => {
                $("#svg").html("");
                $("#legend").html("");
                if (hasNestingOrderChanged) {
                    create_treemap(reversed_data, $("#treemap-tile").val());
                } else {
                    create_treemap(data, $("#treemap-tile").val());
                }
            });

            $("div").on("change", 'input[type=radio][name=nesting-order]', () => {
                $("#svg").html("");
                $("#legend").html("");
                let nestingNum = $('input[type=radio][name=nesting-order]:checked').val();
                if (nestingNum === "1") {
                    hasNestingOrderChanged = false;
                    create_treemap(data, $("#treemap-tile").val());
                } else {
                    hasNestingOrderChanged = true;
                    create_treemap(reversed_data, $("#treemap-tile").val());
                }
            });
        });

        var videos = []; // Your videos URLs here

        async function fetchVideoUrl(keyword) {
            try {
                const response = await fetch(`http://localhost:3000/proxy?q=${keyword}`);
                const data = await response.json();
                if (data && data.collection && data.collection.items.length > 0) {
                    const videoUrl = data.collection.items[0].links.find(link => link.render === "mp4").href;
                    return videoUrl;
                }
            } catch (error) {
                console.error("Error fetching video URL:", error);
            }
            return null;
        }

        async function loadVideos() {
            for (let keyword of data.keywords) {
                const videoUrl = await fetchVideoUrl(keyword);
                if (videoUrl) {
                    videos.push(videoUrl);
                }
            }
            // Now you can create the treemap with video URLs
            create_treemap(data, "treemapSquarify");
        }

        loadVideos();
    </script>
</body>
</html>
