<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Treemap Visualization</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
        }
        .node {
            box-sizing: border-box;
            border: 1px solid white;
            overflow: hidden;
            position: absolute;
            text-align: center;
        }
        .node .label {
            font-size: 12px;
            color: white;
        }
        .legend {
            font-size: 12px;
            cursor: pointer;
        }
        .legend rect {
            stroke-width: 2;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="treemap-tile">Tile Method:</label>
        <select id="treemap-tile">
            <option value="treemapSquarify">Squarify</option>
            <option value="treemapBinary">Binary</option>
            <option value="treemapDice">Dice</option>
            <option value="treemapSlice">Slice</option>
            <option value="treemapSliceDice">SliceDice</option>
            <option value="treemapResquarify">Resquarify</option>
        </select>

        <label for="nesting-order">Nesting Order:</label>
        <input type="radio" name="nesting-order" value="1" checked> Source > Category > Keyword
        <input type="radio" name="nesting-order" value="2"> Category > Source > Keyword
    </div>
    <div id="svg"></div>
    <div id="legend"></div>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        var tiles = {
            "treemapSquarify": d3.treemapSquarify,
            "treemapBinary": d3.treemapBinary,
            "treemapDice": d3.treemapDice,
            "treemapSlice": d3.treemapSlice,
            "treemapSliceDice": d3.treemapSliceDice,
            "treemapResquarify": d3.treemapResquarify
        };

        var hasNestingOrderChanged = false;
        var data, reversed_data;

        // Placeholder for acronyms
        var acronyms = {
            // Define your acronyms here
            // "NASA": { "name": "National Aeronautics and Space Administration" }
        };

        d3.json("data.json").then(originalData => {
            data = clean_data_treemap(originalData);
            reversed_data = changeNesting(data);
            create_treemap(data, "treemapSquarify");
        });

        var fetchImageUrl = async (keyword) => {
            const response = await fetch(`https://api.unsplash.com/search/photos?query=nasa+${keyword}&client_id=YOUR_ACCESS_KEY`);
            const data = await response.json();
            return data.results[0]?.urls?.small || 'default-image.jpg';
        };

        var create_treemap = async (data, tile) => {
            let format = d3.format(",d");
            let legendKeys = [];
            let margin = ({ top: 0, right: 0, bottom: 5, left: 0 });

            let width = window.innerWidth;
            let height = window.innerHeight;

            let treemap = data => d3.treemap()
                .tile(tiles[tile])
                .size([width, height])
                .padding(1.5)
                .round(true)
                (d3.hierarchy(data)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value));

            let chart = async () => {
                const root = treemap(data);

                // Tree map vis
                const svg = d3.select("#svg").append("svg")
                    .attr("viewBox", [0, 0, width + margin.left + margin.right, height + margin.top + margin.bottom])
                    .style("font", "0.6em sans-serif");

                const leaf = svg.selectAll("g")
                    .data(root.leaves())
                    .join("g")
                    .attr("transform", d => `translate(${d.x0 + margin.left}, ${d.y0 + margin.top})`);

                leaf.append("title")
                    .text(d => {
                        let arr = d.ancestors().reverse().map(d => d.data.name);
                        let outStr;
                        // Creating the tooltip text
                        if (hasNestingOrderChanged) {
                            outStr = `Keyword: ${d.data.name}\nUpload Source: ${arr[2]}\nCategory: ${arr[1]}\n\nCount: ${format(d.value)}`;
                        } else {
                            outStr = `Keyword: ${d.data.name}\nUpload Source: ${arr[1]}\nCategory: ${arr[2]}\n\nCount: ${format(d.value)}`;
                        }
                        return outStr;
                    });

                leaf.append("a")
                    .attr("xlink:href", d => {
                        let arr = d.ancestors().reverse().map(d => d.data.name);
                        let outStr;
                        // Creating the tooltip text
                        if (hasNestingOrderChanged) {
                            outStr = `Keyword: ${d.data.name}\nUpload Source: ${arr[2]}\nCategory: ${arr[1]}\n\nCount: ${format(d.value)}`;
                        } else {
                            outStr = `Keyword: ${d.data.name}\nUpload Source: ${arr[1]}\nCategory: ${arr[2]}\n\nCount: ${format(d.value)}`;
                        }
                        return `https://data.nasa.gov/browse?q= ${d.data.name}\n+ ${arr[1]}\n+ ${arr[2]}\n\n&sortBy=relevance`;
                    })
                    .append("image")
                    .attr("href", async d => await fetchImageUrl(d.data.name))
                    .attr("width", d => d.x1 - d.x0)
                    .attr("height", d => d.y1 - d.y0)
                    .attr("preserveAspectRatio", "xMidYMid slice");

                var svg2 = d3.select("#legend")
                    .append("svg")
                    .attr("width", 500)
                    .attr("height", 25 * legendKeys.length);
                
                // Legend vis
                var legend = svg2.append("g")
                    .attr("class", "legend")
                    .attr('transform', 'translate(-20, 13)');  

                legend.append('g')
                    .selectAll('.legend-group')
                    .data(legendKeys)
                    .join('g')
                    .attr('class', 'legend')
                    .attr('transform', (d, i) => `translate(20, ${i * 23})`)
                    .append('rect')
                        .attr('fill', (d) => color(d))
                        .attr('opacity', 0.7)
                        .attr('width', 15)
                        .attr('height', 15)
                        .attr('rx', 3);

                legend.selectAll('.legend')
                    .append('text')
                    .attr('font-size', "1em")
                    .attr('transform', (d, i) => `translate(19, 12)`)
                    .attr("class", "legend-text")
                    .text((d) => {return d})
                    .on("click", (d) => {
                        document.location.href = `https://data.nasa.gov/browse?q=${d}&sortBy=relevance`;
                    });
            };
            await chart();
        };

        // Created to emulate observable's "DOM.uid()" method
        // Used for the treemap's clip path
        var ID = (type) => {
            let out = {};
            let id_num = Math.random().toString(36).substr(2, 9);
            out["id"] = `O-${type}-${id_num}`;
            out["href"] = `${window.location.href}#${out["id"]}`;
            return out;
        };

        // Swaps out acronyms using acronyms.json
        swap_acronyms = (str) => {
            if (str in acronyms) {
                return toTitleCase(acronyms[str]["name"]);
            } else {
                return toTitleCase(str);
            }
        };

        // Removes Categories and sources if empty
        clean_data_treemap = (data) => {
            for (let i = 0; i < data["children"].length; i++) {
                // Checking if acronym has to be switched out
                data["children"][i]["name"] = swap_acronyms(data["children"][i]["name"]);
                for (let j = 0; j < data["children"][i]["children"].length; j++) {
                    // Checking if acronym has to be switched out
                    data["children"][i]["children"][j]["name"] = swap_acronyms(data["children"][i]["children"][j]["name"]);
                    // Removing category if empty
                    if (data["children"][i]["children"][j]["children"].length === 0) {
                        data["children"][i]["children"].splice(j, 1);
                        // Going back an index since element at current index
                        // Just got spliced
                        j--;
                    }
                }
                // Remove Source if its empty
                if (data["children"][i]["children"].length === 0) {
                    data.children.splice(i, 1);
                    // Going back an index since element at current index
                    // Just got spliced
                    i--;
                } 
            }
            return data;
        };

        // Changes the nesting order of the data from:
        // Source > Category > Keyword to ->
        // Category > Source > Keyword
        changeNesting = (data) => {
            var out = {"name": "datasets", "children": []};
            var obj = {};
            // Used to hold objects before being appended
            var temp_obj;
            var temp_obj2;
            var temp_obj3;

            // Begin looping through sources
            for (let i = 0; i < data["children"].length; i++) {
                // Begin looping through the categories within each source
                for (let j = 0; j < data["children"][i]["children"].length; j++) {
                    // Checking if the category's "children" array has any keywords
                    if (data["children"][i]["children"][j]["children"].length !== 0) {
                        // If the output obj does not yet have an element <category name>, create one
                        if (!obj.hasOwnProperty(data["children"][i]["children"][j]["name"])) {
                            obj[data["children"][i]["children"][j]["name"]] = {};
                        }
                        obj[data["children"][i]["children"][j]["name"]][data["children"][i]["name"]] = {};
                        // Changes the nesting order 
                        for (let x = 0; x < data["children"][i]["children"][j]["children"].length; x++) {
                            obj[data["children"][i]["children"][j]["name"]][data["children"][i]["name"]][data["children"][i]["children"][j]["children"][x]["name"]] = data["children"][i]["children"][j]["children"][x]["value"];
                        }
                    }
                }
            }
            // After the main obj is built, format the data correctly for D3
            for (let [category, cat_children] of Object.entries(obj)) {
                temp_obj = {};
                temp_obj["name"] = category;
                temp_obj["children"] = [];

                for (let [source, src_children] of Object.entries(cat_children)) {
                    temp_obj2 = {};
                    temp_obj2["name"] = source;
                    temp_obj2["children"] = [];   

                    for (let [kw, count] of Object.entries(src_children)) {
                        temp_obj3 = {};
                        temp_obj3["name"] = kw;
                        temp_obj3["value"] = count;
                        temp_obj2["children"].push(temp_obj3);
                    } 
                    temp_obj["children"].push(temp_obj2);           
                }
                out["children"].push(temp_obj);
            }
            return out;
        };

        // Capitalizes first letter of every word in a string
        var toTitleCase = (str) => {
            return str.replace(/\w\S*/g, function(txt){
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        };

        ///=======/// EVENT LISTENERS: ///=======///

        // When user changes treemap view
        $("div").on("change", "#treemap-tile", () => {
            $("#svg").html("");
            $("#legend").html("");
            if (hasNestingOrderChanged) {
                create_treemap(reversed_data, $("#treemap-tile").val());
            } else {
                create_treemap(data, $("#treemap-tile").val());
            }
        });

        // When user changes nesting order
        $("div").on("change", 'input[type=radio][name=nesting-order]', () => {
            $("#svg").html("");
            $("#legend").html("");
            let nestingNum = $('input[type=radio][name=nesting-order]:checked').val();
            if (nestingNum === "1") {
                hasNestingOrderChanged = false;
                create_treemap(data, $("#treemap-tile").val());
            } else {
                hasNestingOrderChanged = true;
                create_treemap(reversed_data, $("#treemap-tile").val()); 
            }   
        });
    </script>
</body>
</html>
